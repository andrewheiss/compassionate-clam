---
title: Model details
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align = "center", fig.retina = 3,
                      fig.width = 6, fig.height = (6 * 0.618),
                      out.width = "80%", collapse = TRUE,
                      dev = "png", dev.args = list(type = "cairo-png"))

options(digits = 3, width = 120,
        dplyr.summarise.inform = FALSE,
        knitr.kable.NA = "")
```

```{r load-libraries, warning=FALSE, message=FALSE}
library(tidyverse)
library(targets)
library(brms)
library(marginaleffects)
library(tidybayes)
library(ggdist)
library(patchwork)
library(scales)
library(glue)
library(gt)
library(gtExtras)

# Generated via random.org
set.seed(196491)

# Load targets
tar_load(ongo)
tar_load(c(m_full_ordbeta, m_full_interaction_ordbeta))
invisible(list2env(tar_read(graphic_functions), .GlobalEnv))
invisible(list2env(tar_read(table_functions), .GlobalEnv))

prop_to_provinces <- function(x, lower = 1, upper = 32) {
  (x * (upper - lower)) + lower
}
```

TODO: Formal definition and justification for ordered beta instead of ZOIB

```{r build-posterior-preds}
full_posterior <- predicted_draws(m_full_ordbeta, 
                                  newdata = m_full_ordbeta$data, 
                                  ndraws = 100)

posterior_categories <- full_posterior |> 
  ungroup() |> 
  mutate(outcome = case_when(
    .prediction == 0 ~ "1",
    .prediction > 0 & .prediction < 1 ~ "1–32",
    .prediction == 1 ~ "32"
  )) |> 
  group_by(outcome, .draw) |> 
  summarize(count = n()) |> 
  ungroup()

actual_counts <- m_full_ordbeta$data |> 
  mutate(outcome = case_when(
    province_count == 0 ~ "1",
    province_count > 0 & province_count < 1 ~ "1–32",
    province_count == 1 ~ "32"
  )) |> 
  group_by(outcome) |> 
  summarize(count = n())

plot_categories <- posterior_categories |> 
  ggplot(aes(x = outcome, y = count)) +
  geom_col(data = actual_counts, fill = "grey70") +
  stat_pointinterval() +
  labs(x = NULL, y = "Observed and predicted counts",
       title = "Posterior predictions of discrete and continuous outcomes") +
  coord_cartesian(ylim = c(0, 300)) +
  theme_ongo()

actual_middle <- m_full_ordbeta$data |> 
  filter(province_count > 0 & province_count < 1) |> 
  mutate(province_count = prop_to_provinces(province_count)) 

plot_continuous <- full_posterior |> 
  mutate(.prediction = prop_to_provinces(.prediction)) |> 
  filter(.prediction > 1 & .prediction < 32) |> 
  ggplot(aes(x = .prediction, group = .draw)) +
  geom_density(linewidth = 0.05, bounds = c(1, 32)) +
  geom_density(data = actual_middle, aes(x = province_count),
               inherit.aes = FALSE, bounds = c(1, 32)) +
  labs(x = "Discrete and continuous predicted outcomes",
       y = "Probability density") +
  theme_ongo()
```

```{r combined-posterior-preds, fig.width=6, fig.height=5}
arrow_part <- ggplot() +
  annotate(geom = "segment", x = 0.35, xend = 0.65, y = 0.9, yend = 0.9) +
  annotate(geom = "segment", x = 0.5, xend = 0.5, y = 0.9, yend = 0.1,
           arrow = arrow(angle = 30, type = "closed", length = unit(0.1, "inches"))) +
  scale_x_continuous(limits = c(0, 1)) +
  theme_void()

plot_categories / arrow_part / plot_continuous +
  plot_layout(heights = c(0.45, 0.1, 0.45))
```


```{r}
# ordbetareg's built-in way, just to check
# pp_check_ordbeta(m_full_ordbeta, ndraws = 100)
```


TODO: MCMC diagnostics

TODO: Timing

```{r calculate-model-times}
models <- tribble(
  ~model_name, ~model,
  "Full model", m_full_ordbeta,
  "Full model with `local_connect * years_since_law` interaction", m_full_interaction_ordbeta,
) |> 
  mutate(duration = map(model, ~{
    .$fit |> 
      rstan::get_elapsed_time() |> 
      as_tibble() |> 
      summarize(total = as.duration(max(warmup + sample)))
  })) |> 
  select(-model) |> 
  unnest(duration)

dur <- as.period(as.duration(sum(models$total)))

total_run_time <- glue(
  "{hours} hours, {minutes} minutes, and {seconds} seconds",
  hours = hour(dur), minutes = minute(dur), seconds = round(second(dur), 0)
)
```

We ran these models on a 2021 M1 MacBook Pro with 32 GB of RAM, with 4 MCMC chains spread across 8 cores, with two CPU threads per chain, using Stan through brms through cmdstanr. 

In total, it took `r total_run_time` to run everything.

```{r mcmc-duration-table}
models |> 
  gt() |> 
  tab_footnote(
    footnote = "Duration of the longest-running MCMC chain",
    locations = cells_column_labels(columns = total)
  ) |> 
  cols_label(
    model_name = "Model",
    total = "Total time"
  ) |> 
  cols_align(
    align = "left",
    columns = everything()
  ) |>
  fmt_markdown(columns = model_name) |> 
  grand_summary_rows(
    columns = c(total),
    fns = list(`Overall total` = ~as.duration(sum(.)))
  ) |> 
  opt_footnote_marks(marks = "standard") |> 
  opt_horizontal_padding(3) |> 
  opts_theme()
```
